# 异步迭代和 generator

异步迭代允许我们对按需通过异步请求而得到的数据进行迭代。例如，我们通过网络分段(chunk-by-chunk)下载数据时。异步生成器(generator)使这一步更加方便。

首先，让我们来看一个简单的示例以掌握语法，然后再看一个实际用例。

## 回顾可迭代对象

让我们回顾一下迭代对象的相关内容。

假设我们有一个对象，例如下面的`range`:

```js
let range = {
  from: 1,
  to: 5,
};
```

我们想对它使用`for..of`循环，例如`for(value of range)`，来获取从`1`到`5`的值。

换句话说，我们想向对象`range`添加**迭代能力**。

这可以通过使用一个名为`Symbol.iterable`的特殊方法来实现:

- 当循环开始时，该方法被`for..of`结果调用，并且它应该返回一个带有`next`方法的对象。
- 对于每次迭代，都会成为下一个值调用`next()`方法。
- `next()`方法应该以`{done:true/false,value:<loop value>}`的格式返回一个值，其中`done:true`表示循环结果。

这是可迭代的`range`的一个实现:

```js
let range = {
  from: 1,
  to: 5,

  [Symbol.iterable]() {
    // 在for..of 循环开始时被调用一次
    return {
      current: this.from,
      last: this.to,

      next() {
        // 每次迭代时都会被调用
        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      },
    };
  },
};

for (let value of range) {
  alert(value); // 1 ,然后2 ，然后3 ， 然后 4 ， 然后 5
}
```

如果有任何不清楚的，可以阅读[Iterable object(可迭代对象)](https://zh.javascript.info/iterable)一章，其中详细讲解了关于常规迭代器(iterator)的所有内容。

## 异步可迭代对象

当值是以异步的形式出现时，例如在`setTimeout`或者另一种延迟之后，就需要异步迭代。

最常见的场景是，对象需要发送一个网络请求以传递下一个值，稍后我们将看到一个它的真实示例。

要使对象异步迭代:

1. 使用`Symbol.asyncIterator`取代`Symbol.iterator`。
2. `next()`方法应该返回一个`promise`(带有下一个值，并且状态为`fulfilled`)。
   - 关键字`async`可以实现这一点，我们可以简单地使用`async next()`。
3. 我们应该使用`for await (let item of iterable)`循环来迭代这样的对象。
   - 注意关键字`await`。

作为开始的示例，让我们创建一个可迭代的`range`对象，与前面的那个类型，不过现在它将异步地每秒返回一个值。

我们需要做的就是对上面代码中的部分代码进行替换:

```js
let range = {
  from: 1,
  to: 5,

  [Symbol.asyncIterator]() {
    //(1)
    return {
      current: this.from,
      last: this.to,

      async next() {
        //(2)

        //注意：我们可以在 async next 内部使用 "await"
        await new Promise((resolve) => setTimeout(resolve, 1000)); //(3)

        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      },
    };
  },
}(async () => {
  for await (let value of range) {
    //(4)
    alert(value); // 1,2,3,4,5
  }
})();
```

正如我们所看到的，其结构与常规的 iterator 类似:

1. 为了使一个对象可以异步迭代，它必须具有方法`Symbol.asyncIterator` `(1)`。
2. 这个方法必须返回一个带有`next()`方法的对象，`next()`方法会返回一个 promise`(2)`。
3. 这个`next()`方法可以不是`async`的，它可以是一个返回值是一个`promise`的常规的方法，但是使用`async`关键字可以允许我们在方法内部使用`await`，所以会更加方便。这里我们只是用于延迟 1 秒的操作 `(3)`。
4. 我们使用`for await(let value of range)` `(4)` 来进行迭代，也就是在`for`后面添加`await`。它会调用一次`range[Symbol.asyncIterator]()`方法一次，然后调用它的`next()`方法获取值。

这是一个对比 Iterable 和异步 iterator 之间差异的表格:
||**Iterator**|**异步 iterator**|
|:---:|:------:|:-----:|
|提供 iterator 的对象方法|`Symbol.iterator`|`Symbol.asyncIterator`|
|`next()`返回的值是|任意值|Promise|
|要进行循环，使用|`for..of`|`for await..of`|

> **Spread 语法`...`无法异步工作**
> 需要常规的同步 iterator 的功能，无法与正常 iterator 一起使用。
>
> 例如，spread 语法无法工作:
>
> ```js
> alert([...args]); //Error,no Symbol.iterator
> ```
>
> 这很正常，因为他期望找到`Symbol.iterator`，而不是`Symbol.asyncIterator`。
>
> `for..of`的情况和这个一样：没有`await`关键字时，则期望找到的是`Symbol.iterator`。

## 回顾 generator

现在，让我们回顾一下 generator，它使我们能够写出更短的迭代代码。在大多数的时候，当我们想要创建一个可迭代对象时，我们会使用 generator。

简单起见，这里省略一些解释，即 generator 是"生成(yield)值的函数"。关于我们可以使用`for..of`循环来遍历它们。

下面这个例子生成了从`start`到`end`的一系列值:

```js
function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) {
    yield 1;
  }
}

for (let value of generateSequence(1, 5)) {
  alert(value); //1,然后是2，然后2，然后3，然后4，然后5
}
```

正如我们所知道的，要使一个对象可迭代。我们需要给它添加`Symbol.iterator`。

```js
  let range = {
    from:1,
    to:5,
    [Symbol.iterator] () {
      return <带有 next 方法的对象，以使对象 range 可迭代>
    }
  }
```

对于`Symbol.iterator`来说，一个通常的做法是返回一个 generator，这样可以使代码更短，如下所示:

```js
let range = {
  from: 1,
  to: 5,

  *[Symbol.iterator]() {
    //[Symbol.iterator]:function*() 的一种简写
    for (let value = this.from; value <= this.to; value++) {
      yield value;
    }
  },
};

for (let value of range) {
  alert(value); //1,然后是2，然后2，然后3，然后4，然后5
}
```

如果你想了解更多详细内容，请阅读 generator 一章。

在常规的 generator 中，我们无法使用`await`。所有的值都必须按照`for..of`构造的要求同步地出现。

如果我们想要异步生成值该怎么办？例如，对于来自网络请求的值。

让我们再回到异步 generator，来使这个需求成为可能。

## 异步 generator(finally)

对于大多数的实际应用程序，当我们想创建一个异步生成一系列值的对象时，我们都可以使用异步 generator。

语法很简单:在`function*`前面加上`async`。这即可使 generator 变为异步的。

然后使用`for await(...)`来遍历它，就像这样:

```js
  async function* generateSequence(start,end){

    for(let i = start; i<=end; i++) {

      //哇，可以使用await了！
      await new Promise(resolve => setTimeout(resolve,1000));

      yield 1;
    }
  }

  (async() = {

    let generator = generateSequence(1,5);
    for await (let value of generator) {
      alert(value); //1,然后是2，然后2，然后3，然后4，然后5(在每个alert之间有延迟)
    }
  })
```

因为此 generator 是异步的，所以我们可以在其内部使用`await`，依赖于`promise`，执行网络请求等任务。

> **引擎盖下的差异**
> 如果你还记得我们在前面讲的关于 generator 的细节知识，那你应该知道，从技术上讲，异步 generator 和常规 generator 在内部是有区别的。
>
> 对于异步的 generator，`generator.next()`方法是异步的，它返回 promise。
>
> 在一个常规的 generator 中，我们使用`result = generator.next()`来获得值，但在一个异步 generator 中，我们应该添加`await`关键字，像这样:
>
> ```js
> result = await generator.next();
> ```
>
> 这就是为什么异步 generator 可以与`for await...of`一起工作。

### 异步的可迭代对象 range

常规的 generator 可用作`Symbol.iterator`以使迭代代码更短。

与之类似，异步 generator 可用作
`Symbol.asyncIterator`来实现异步迭代。

例如，我们可以通过将同步的`Symbol.iterator`替换为异步的`Symbol.asyncIterator`,来使对象`range`异步地生成值，每秒生成一个:

```js
  let range = {
    from:1,
    to:5.

    //这一行等价于 [Symbol.asyncIterator]:async function*() {
      async *[Symbol.asyncIterator]() {
        for(let value = this.from; value <= this.to; value++) {

          //在value之间暂停一会，等待一些东西
          await new Promise(resolve => setTimeout(resolve,1000));

          yield value;
        }
      }
    };
    (async ()=>{

      for(await (let value of range) {
        alert(value); //1,然后是2，然后2，然后3，然后4，然后5
      })
    })();
```

现在，value 之间延迟为 1 秒。

> **请注意：**
> 从技术上讲，我们可以把`Symbol.iterator`和
> `Symbol.asyncIterator`都添加到对象中，因此它既可以是同步的(`for..of`)也可以是异步的(`for await..of`)可迭代对象。
>
> 但是实际上，这将是一件很奇怪的事。
