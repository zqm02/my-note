# 异步迭代和 generator

异步迭代允许我们对按需通过异步请求而得到的数据进行迭代。例如，我们通过网络分段(chunk-by-chunk)下载数据时。异步生成器(generator)使这一步更加方便。

首先，让我们来看一个简单的示例以掌握语法，然后再看一个实际用例。

## 回顾可迭代对象

让我们回顾一下迭代对象的相关内容。

假设我们有一个对象，例如下面的`range`:

```js
let range = {
  from: 1,
  to: 5,
};
```

我们想对它使用`for..of`循环，例如`for(value of range)`，来获取从`1`到`5`的值。

换句话说，我们想向对象`range`添加**迭代能力**。

这可以通过使用一个名为`Symbol.iterable`的特殊方法来实现:

- 当循环开始时，该方法被`for..of`结果调用，并且它应该返回一个带有`next`方法的对象。
- 对于每次迭代，都会成为下一个值调用`next()`方法。
- `next()`方法应该以`{done:true/false,value:<loop value>}`的格式返回一个值，其中`done:true`表示循环结果。

这是可迭代的`range`的一个实现:

```js
let range = {
  from: 1,
  to: 5,

  [Symbol.iterable]() {
    // 在for..of 循环开始时被调用一次
    return {
      current: this.from,
      last: this.to,

      next() {
        // 每次迭代时都会被调用
        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      },
    };
  },
};

for (let value of range) {
  alert(value); // 1 ,然后2 ，然后3 ， 然后 4 ， 然后 5
}
```

如果有任何不清楚的，可以阅读[Iterable object(可迭代对象)](https://zh.javascript.info/iterable)一章，其中详细讲解了关于常规迭代器(iterator)的所有内容。

## 异步可迭代对象

当值是以异步的形式出现时，例如在`setTimeout`或者另一种延迟之后，就需要异步迭代。

最常见的场景是，对象需要发送一个网络请求以传递下一个值，稍后我们将看到一个它的真实示例。

要使对象异步迭代:

1. 使用`Symbol.asyncIterator`取代`Symbol.iterator`。
2. `next()`方法应该返回一个`promise`(带有下一个值，并且状态为`fulfilled`)。
   - 关键字`async`可以实现这一点，我们可以简单地使用`async next()`。
3. 我们应该使用`for await (let item of iterable)`循环来迭代这样的对象。
   - 注意关键字`await`。

作为开始的示例，让我们创建一个可迭代的`range`对象，与前面的那个类型，不过现在它将异步地每秒返回一个值。

我们需要做的就是对上面代码中的部分代码进行替换:

```js
let range = {
  from: 1,
  to: 5,

  [Symbol.asyncIterator]() {
    //(1)
    return {
      current: this.from,
      last: this.to,

      async next() {
        //(2)

        //注意：我们可以在 async next 内部使用 "await"
        await new Promise((resolve) => setTimeout(resolve, 1000)); //(3)

        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      },
    };
  },
}(async () => {
  for await (let value of range) {
    //(4)
    alert(value); // 1,2,3,4,5
  }
})();
```

正如我们所看到的，其结构与常规的 iterator 类似:

1. 为了使一个对象可以异步迭代，它必须具有方法`Symbol.asyncIterator` `(1)`。
2. 这个方法必须返回一个带有`next()`方法的对象，`next()`方法会返回一个 promise`(2)`。
3. 这个`next()`方法可以不是`async`的，它可以是一个返回值是一个`promise`的常规的方法，但是使用`async`关键字可以允许我们在方法内部使用`await`，所以会更加方便。这里我们只是用于延迟 1 秒的操作 `(3)`。
4. 我们使用`for await(let value of range)` `(4)` 来进行迭代，也就是在`for`后面添加`await`。它会调用一次`range[Symbol.asyncIterator]()`方法一次，然后调用它的`next()`方法获取值。
